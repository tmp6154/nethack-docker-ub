From b28e05c81bcaded3af93cd1d495212a4168045a3 Mon Sep 17 00:00:00 2001
From: Vitaly Ostrosablin <tmp6154@yandex.ru>
Date: Tue, 13 Aug 2019 20:59:53 +0300
Subject: [PATCH] add a new option: autosave

This patch adds a new compound option: autosave (as proposed in GitHub
issue #208).

The idea behind patch is to allow artificially limiting game session
duration, by automatically saving-and-quitting after playing for N turns
(where N is argument of the option). This could be useful for public
servers, where *Robin accounts are used as a form of multiplayer and
players play for N turns, and then give control to another person.
Another use case is to use this option to just keep yourself from
playing too long game sessions (e.g. during coffee-break, etc.).

Option is specified like this:

OPTIONS=autosave:500

Which would save-and-quit after playing for 500 turns.

Defaults to -1 (autosave disabled). 0 is invalid value, because game
would then quit right after starting. Any positive value is used as turn
countdown, and when it reaches 0, game is saved and quit automatically.

Signed-off-by: Vitaly Ostrosablin <tmp6154@yandex.ru>

Make autosave option conditional under AUTOSAVE define

Signed-off-by: Vitaly Ostrosablin <tmp6154@yandex.ru>

autosave: make option settable in-game

Signed-off-by: Vitaly Ostrosablin <tmp6154@yandex.ru>
---
 dat/opthelp       |  5 +++++
 doc/Guidebook.mn  |  6 ++++++
 doc/Guidebook.tex |  7 +++++++
 doc/Guidebook.txt |  8 ++++++++
 doc/fixes37.0     |  1 +
 include/config.h  |  5 +++++
 include/flag.h    |  3 +++
 src/allmain.c     |  5 +++++
 src/cmd.c         |  4 ++++
 src/options.c     | 35 +++++++++++++++++++++++++++++++++++
 src/save.c        |  4 ++++
 11 files changed, 83 insertions(+)

diff --git a/dat/opthelp b/dat/opthelp
index 1048a19f9..89041c0ff 100644
--- a/dat/opthelp
+++ b/dat/opthelp
@@ -279,6 +279,11 @@ msg_window the type of message window to use:                      [single]
            reverse     -- Same as full, but messages printed most-recent-first
            combination -- Two single messages, then as full
 
+Compound option if AUTOSAVE was set at compile time:
+autosave   Save and quit the game automatically, after playing for    [off]
+           N turns (useful if you want to artificially limit the
+           game session duration).
+
 
 Some sample options lists are:
 !autopickup,!tombstone,name:Gandalf,scores:own/3 top/2 around
diff --git a/doc/Guidebook.mn b/doc/Guidebook.mn
index e189cd8a9..6648e28db 100644
--- a/doc/Guidebook.mn
+++ b/doc/Guidebook.mn
@@ -3549,6 +3549,12 @@ A value of 0 means \(lqno limit\(rq
 the objects\(rq since the pile size will always be at least that big;
 default value is 5.
 Persistent.
+.lp autosave
+Save and quit the game automatically, after playing for N turns
+\(lquseful if you want to artificially limit the game session duration\(rq.
+A value of -1 (and other negative values) mean that autosave is off, while
+positive values are used for turn countdown until save. 0 is not a valid
+turn count because this would cause the game to quit as soon as it starts.
 .lp playmode
 Values are \(lqnormal\(rq, \(lqexplore\(rq, or \(lqdebug\(rq.
 Allows selection of explore mode (also known as discovery mode) or debug
diff --git a/doc/Guidebook.tex b/doc/Guidebook.tex
index 7caa15d8f..51b985749 100644
--- a/doc/Guidebook.tex
+++ b/doc/Guidebook.tex
@@ -3895,6 +3895,13 @@ of showing a popup list of those objects.  A value of 0 means ``no limit''
 the objects'' since the pile size will always be at least that big;
 default value is 5.  Persistent.
 %.lp
+\item[\ib{autosave}]
+Save and quit the game automatically, after playing for N turns
+(useful if you want to artificially limit the game session duration).
+A value of -1 (and other negative values) mean that autosave is off, while
+positive values are used for turn countdown until save. 0 is not a valid
+turn count because this would cause the game to quit as soon as it starts.
+%.lp
 \item[\ib{playmode}]
 Values are {\it normal\/}, {\it explore\/}, or {\it debug\/}.
 Allows selection of explore mode (also known as discovery mode) or debug
diff --git a/doc/Guidebook.txt b/doc/Guidebook.txt
index 9e9fc7b2e..6cda772a3 100644
--- a/doc/Guidebook.txt
+++ b/doc/Guidebook.txt
@@ -3443,6 +3443,14 @@
             command instead.  If no weapon is found or the option is false,
             the `t' (throw) command is executed instead.  Persistent.
 
+          autosave
+            Save and quit the game automatically, after playing for N turns
+            (useful if you want to artificially  limit the game session du-
+            ration).  A value of -1  (and other negative values)  mean that
+            autosave is off, while positive values are used for turn count-
+            down until save. 0 is not a valid turn count because this would
+            cause the game to quit as soon as it starts.
+
           autounlock
             Walking  into a locked door or looting a locked container while
             carrying an unlocking tool (such as a key) will ask whether  to
diff --git a/doc/fixes37.0 b/doc/fixes37.0
index c381d5156..2b54c49e0 100644
--- a/doc/fixes37.0
+++ b/doc/fixes37.0
@@ -169,6 +169,7 @@ teach non-mindless monsters about the Castle trapdoors (github #265)
 always print a message when the hero teleports (github #265)
 always print a message when the hero level teleports (github #265)
 remove Sokoban luck penalties for actions you can't cheat with (github #260)
+autosave option to automatically save-and-quit after N turns (github #213)
 
 
 Code Cleanup and Reorganization
diff --git a/include/config.h b/include/config.h
index f1af270ef..cf47e9767 100644
--- a/include/config.h
+++ b/include/config.h
@@ -570,6 +570,11 @@ typedef unsigned char uchar;
 
 #define USE_ISAAC64 /* Use cross-plattform, bundled RNG */
 
+/* AUTOSAVE enables a new 'autosave' compound option, which allows
+ * to specify max number of turns to play, before doing automatic
+ * save-and-quit, defaults to off. */
+/* #define AUTOSAVE */
+
 /* End of Section 4 */
 
 #ifdef TTY_TILES_ESCCODES
diff --git a/include/flag.h b/include/flag.h
index 1379ebce8..fa8cce75a 100644
--- a/include/flag.h
+++ b/include/flag.h
@@ -252,6 +252,9 @@ struct instance_flags {
     int menu_headings;    /* ATR for menu headings */
     int *opt_booldup;     /* for duplication of boolean opts in config file */
     int *opt_compdup;     /* for duplication of compound opts in conf file */
+#ifdef AUTOSAVE
+    int autosave;         /* controls, how many turns to wait before autosave */
+#endif
 #ifdef ALTMETA
     boolean altmeta;      /* Alt-c sends ESC c rather than M-c */
 #endif
diff --git a/src/allmain.c b/src/allmain.c
index 22faeabd7..a82a298c5 100644
--- a/src/allmain.c
+++ b/src/allmain.c
@@ -195,6 +195,11 @@ boolean resuming;
                     if (flags.time && !g.context.run)
                         iflags.time_botl = TRUE;
 
+#ifdef AUTOSAVE
+                    if (iflags.autosave > 0)
+                        iflags.autosave--;
+#endif
+
                     /* One possible result of prayer is healing.  Whether or
                      * not you get healed depends on your current hit points.
                      * If you are allowed to regenerate during the prayer,
diff --git a/src/cmd.c b/src/cmd.c
index df02c6e4f..69a29def6 100644
--- a/src/cmd.c
+++ b/src/cmd.c
@@ -4824,6 +4824,10 @@ register char *cmd;
 #ifdef SAFERHANGUP
     if (g.program_state.done_hup)
         end_of_input();
+#endif
+#ifdef AUTOSAVE
+    if (!iflags.autosave)
+        dosave();
 #endif
     if (firsttime) {
         g.context.nopick = 0;
diff --git a/src/options.c b/src/options.c
index c95ce0731..1a291dbd8 100644
--- a/src/options.c
+++ b/src/options.c
@@ -278,6 +278,9 @@ static struct Comp_Opt {
     { "align_message", "message window alignment", 20, DISP_IN_GAME }, /*WC*/
     { "align_status", "status window alignment", 20, DISP_IN_GAME },   /*WC*/
     { "altkeyhandler", "alternate key handler", 20, SET_IN_GAME },
+#ifdef AUTOSAVE
+    { "autosave", "quit game after N turns", 20, SET_IN_GAME },
+#endif
 #ifdef BACKWARD_COMPAT
     { "boulder", "deprecated (use S_boulder in sym file instead)", 1,
       SET_IN_GAME },
@@ -713,6 +716,9 @@ initoptions_init()
     flags.end_around = 2;
     flags.paranoia_bits = PARANOID_PRAY; /* old prayconfirm=TRUE */
     flags.pile_limit = PILE_LIMIT_DFLT;  /* 5 */
+#ifdef AUTOSAVE
+    iflags.autosave = -1;                /* Disabled by default */
+#endif
     flags.runmode = RUN_LEAP;
     iflags.msg_history = 20;
     /* msg_window has conflicting defaults for multi-interface binary */
@@ -3091,6 +3097,30 @@ boolean tinitial, tfrom_file;
         return retval;
     }
 
+#ifdef AUTOSAVE
+    /* autosave: play game for N turns, then automatically save-and-quit
+       when safe opportunity presents itself (-1 = no autosave) */
+    fullname = "autosave";
+    if (match_optname(opts, fullname, 5, TRUE)) {
+        if (duplicate)
+            complain_about_duplicate(opts, 1);
+        op = string_for_opt(opts, negated);
+        if ((negated && !op) || (!negated && op))
+            iflags.autosave = negated ? -1 : atoi(op);
+        else if (negated) {
+            bad_negation(fullname, TRUE);
+            return FALSE;
+        } else /* !op */
+            iflags.autosave = -1;
+        /* sanity check - map any negative values to -1 and also map zero to
+           -1 (off) because it doesn't make sense, as it would cause the game
+           to exit as soon as game starts */
+        if (iflags.autosave <= 0)
+            iflags.autosave = -1;
+        return retval;
+    }
+#endif
+
     /* play mode: normal, explore/discovery, or debug/wizard */
     fullname = "playmode";
     if (match_optname(opts, fullname, 4, TRUE)) {
@@ -5802,6 +5832,11 @@ char *buf;
         Sprintf(buf, "%s", ocl[0] ? ocl : "all");
     } else if (!strcmp(optname, "pile_limit")) {
         Sprintf(buf, "%d", flags.pile_limit);
+#ifdef AUTOSAVE
+    } else if (!strcmp(optname, "autosave")) {
+        (iflags.autosave < 0) ? Strcpy(buf, "off")
+        : Sprintf(buf, "%d", iflags.autosave);
+#endif
     } else if (!strcmp(optname, "playmode")) {
         Strcpy(buf, wizard ? "debug" : discover ? "explore" : "normal");
     } else if (!strcmp(optname, "race")) {
diff --git a/src/save.c b/src/save.c
index a8729f735..8fc9cd092 100644
--- a/src/save.c
+++ b/src/save.c
@@ -65,7 +65,11 @@ dosave()
     if (iflags.debug_fuzzer)
         return 0;
     clear_nhwindow(WIN_MESSAGE);
+#ifdef AUTOSAVE
+    if (iflags.autosave && yn("Really save?") == 'n') {
+#else
     if (yn("Really save?") == 'n') {
+#endif
         clear_nhwindow(WIN_MESSAGE);
         if (g.multi > 0)
             nomul(0);
-- 
2.24.1

